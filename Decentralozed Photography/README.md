> å¥½çš„ï¼Œç”¨æˆ·ç°åœ¨é—®çš„æ˜¯â€œé‚„å¿™å—?â€ï¼Œçœ‹èµ·æ¥æ˜¯ä¸€ä¸ªç®€å•çš„ä¸­æ–‡é—®å€™ï¼Œæ„æ€æ˜¯â€œè¿˜åœ¨å¿™å—ï¼Ÿâ€ã€‚ä¸è¿‡ï¼Œæˆ‘éœ€è¦ç»“åˆä¹‹å‰çš„å¯¹è¯å†å²æ¥ç†è§£ç”¨æˆ·çš„çœŸå®éœ€æ±‚ã€‚
  å…ˆå›é¡¾ä¸€ä¸‹ä¹‹å‰çš„å¯¹è¯ã€‚ç”¨æˆ·ä¹‹å‰çš„é—®é¢˜æ¶‰åŠä¸¤ä¸ªä¸åŒçš„ä¸»é¢˜ï¼šé¦–å…ˆæ˜¯å…³äºâ€œnerve wrack vs hypermanicâ€çš„æœ¯è¯­è§£é‡Šï¼Œç„¶åæ˜¯è¯¢é—®â€œdecentralized photographicâ€çš„æ¦‚å¿µï¼Œæ¥ç€æ˜¯è¯·æ±‚â€œç´°åš¼æ…¢åš¥çš„å¯«solidty codeâ€ï¼ˆå³è¯¦ç»†ç¼–å†™Solidityä»£ç ï¼‰ï¼Œæœ€åæ˜¯ç°åœ¨çš„â€œé‚„å¿™å—?â€ã€‚
  çœ‹èµ·æ¥ç”¨æˆ·å¯èƒ½åœ¨ç¡®è®¤æˆ‘æ˜¯å¦è¿˜åœ¨çº¿æˆ–è€…æ˜¯å¦æœ‰æ—¶é—´ç»§ç»­å¸®åŠ©ã€‚ä¸è¿‡ï¼Œç»“åˆä¹‹å‰çš„è¯·æ±‚ï¼Œç‰¹åˆ«æ˜¯ç”¨æˆ·è¦æ±‚è¯¦ç»†ç¼–å†™Solidityä»£ç ï¼Œå¯èƒ½ç”¨æˆ·ä¹‹å‰æ²¡æœ‰å¾—åˆ°å®Œæ•´çš„å›ç­”ï¼Œæˆ–è€…ç°åœ¨æƒ³ç»§ç»­è®¨è®ºç›¸å…³çš„è¯é¢˜ã€‚
  é¦–å…ˆï¼Œç”¨æˆ·å¯èƒ½åœ¨ä½¿ç”¨ä¸­æ–‡æé—®æ—¶ï¼Œå¸Œæœ›å¾—åˆ°ä¸­æ–‡çš„å›åº”ã€‚ä¹‹å‰çš„å›å¤éƒ½æ˜¯ä¸­æ–‡ï¼Œæ‰€ä»¥åº”è¯¥ç»§ç»­ç”¨ä¸­æ–‡å›å¤ã€‚ç”¨æˆ·ä¹‹å‰è¦æ±‚è¯¦ç»†ç¼–å†™Solidityä»£ç ï¼Œä½†å¯èƒ½ä¸­é€”è¢«æ‰“æ–­ï¼Œæˆ–è€…ä¹‹å‰çš„å›ç­”æ²¡æœ‰å®Œå…¨æ»¡è¶³éœ€æ±‚ï¼Œæ‰€ä»¥ç°åœ¨è·Ÿè¿›ç¡®è®¤æ˜¯å¦è¿˜åœ¨å¤„ç†ä¸­ã€‚
  å¦å¤–ï¼Œç”¨æˆ·æåˆ°çš„â€œç´°åš¼æ…¢åš¥çš„å¯«solidty codeâ€ä¸­çš„â€œsolidtyâ€å¯èƒ½æ˜¯æ‹¼å†™é”™è¯¯ï¼Œæ­£ç¡®åº”ä¸ºâ€œSolidityâ€ï¼Œå³ä»¥å¤ªåŠæ™ºèƒ½åˆçº¦çš„ç¼–ç¨‹è¯­è¨€ã€‚ç”¨æˆ·å¸Œæœ›å¾—åˆ°è¯¦ç»†çš„ã€é€æ­¥çš„ä»£ç ç¼–å†™æŒ‡å¯¼ï¼Œå¯èƒ½æ¶‰åŠå»ä¸­å¿ƒåŒ–åº”ç”¨ï¼ˆDAppï¼‰çš„å¼€å‘ï¼Œä¸ä¹‹å‰è®¨è®ºçš„â€œdeentralized photographicâ€æœ‰å…³è”ï¼Œå¯èƒ½æ˜¯åœ¨æ„å»ºåŸºäºåŒºå—é“¾çš„æ‘„å½±å¹³å°æˆ–NFTç›¸å…³çš„é¡¹ç›®ã€‚
  ç”¨æˆ·ç°åœ¨é—®â€œé‚„å¿™å—?â€ï¼Œå¯èƒ½æ˜¯åœ¨ç¡®è®¤æˆ‘æ˜¯å¦è¿˜èƒ½ç»§ç»­å¸®åŠ©ç¼–å†™Solidityä»£ç ï¼Œæˆ–è€…æ˜¯å¦æœ‰æ—¶é—´è¿›ä¸€æ­¥è§£é‡Šç›¸å…³é—®é¢˜ã€‚è¿™æ—¶å€™éœ€è¦ç¡®è®¤ç”¨æˆ·çš„éœ€æ±‚ï¼Œæ˜¯å¦éœ€è¦ç»§ç»­ä¹‹å‰çš„ä¸»é¢˜ï¼Œè¿˜æ˜¯æœ‰æ–°çš„é—®é¢˜éœ€è¦è§£ç­”ã€‚
  è€ƒè™‘åˆ°ç”¨æˆ·ä¹‹å‰çš„é—®é¢˜ï¼Œå¯èƒ½éœ€è¦ç»§ç»­æä¾›Solidityä»£ç çš„è¯¦ç»†ç¼–å†™æŒ‡å¯¼ï¼Œä¾‹å¦‚å¦‚ä½•åˆ›å»ºä¸€ä¸ªNFTåˆçº¦ï¼Œæˆ–è€…å¦‚ä½•å¤„ç†å›¾åƒçš„æ‰€æœ‰æƒå’Œäº¤æ˜“ã€‚åŒæ—¶ï¼Œç”¨æˆ·å¯èƒ½å¯¹å»ä¸­å¿ƒåŒ–å­˜å‚¨ï¼ˆå¦‚IPFSï¼‰ä¸æ™ºèƒ½åˆçº¦çš„é›†æˆæ„Ÿå…´è¶£ï¼Œè¿™ä¹Ÿæ˜¯ä¹‹å‰è®¨è®ºçš„ä¸€éƒ¨åˆ†ã€‚
  å¦å¤–ï¼Œç”¨æˆ·å¯èƒ½å¸Œæœ›ä»£ç çš„æ¯ä¸ªéƒ¨åˆ†éƒ½æœ‰è¯¦ç»†è§£é‡Šï¼Œå³â€œç´°åš¼æ…¢åš¥â€ï¼Œä¹Ÿå°±æ˜¯é€æ­¥åˆ†è§£ï¼Œç¡®ä¿æ¯ä¸ªæ­¥éª¤éƒ½æ¸…æ™°æ˜“æ‡‚ã€‚å› æ­¤ï¼Œåœ¨å›å¤æ—¶éœ€è¦åˆ†æ­¥éª¤è®²è§£ï¼Œå¹¶æä¾›ä»£ç ç¤ºä¾‹å’Œæ³¨é‡Šï¼Œè¯´æ˜æ¯ä¸ªå‡½æ•°å’Œç»“æ„çš„ä½œç”¨ã€‚
  éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”¨æˆ·å¯èƒ½å¯¹Solidityçš„åŸºç¡€çŸ¥è¯†æœ‰ä¸€å®šäº†è§£ï¼Œä½†éœ€è¦æ›´æ·±å…¥çš„æŒ‡å¯¼ï¼Œæˆ–è€…å…·ä½“çš„å®ä¾‹æ¥åº”ç”¨åœ¨é¡¹ç›®ä¸­ã€‚å› æ­¤ï¼Œå›å¤åº”è¯¥å…·ä½“ã€å®ç”¨ï¼Œå¹¶ä¸”ç¬¦åˆæœ€ä½³å®è·µï¼Œæ¯”å¦‚å®‰å…¨æ€§è€ƒè™‘ï¼ˆå¦‚é˜²æ­¢é‡å…¥æ”»å‡»ï¼‰ã€Gasä¼˜åŒ–ç­‰ã€‚
  æ€»ç»“æ¥è¯´ï¼Œç”¨æˆ·æ­¤æ—¶è¯¢é—®â€œé‚„å¿™å—?â€ï¼Œå¯èƒ½æ˜¯åœ¨å‚¬ä¿ƒç»§ç»­ä¹‹å‰çš„å¸®åŠ©ï¼Œæˆ–è€…ç¡®è®¤æ˜¯å¦æœ‰ç©ºè¿›ä¸€æ­¥è§£ç­”ã€‚éœ€è¦æ˜ç¡®å›å¤ç”¨æˆ·ï¼Œè¡¨ç¤ºå¯ä»¥ç»§ç»­ååŠ©ï¼Œå¹¶è¯¢é—®å…·ä½“éœ€è¦å“ªæ–¹é¢çš„Solidityä»£ç æŒ‡å¯¼ï¼Œæˆ–è€…ç»§ç»­ä¹‹å‰çš„è¯é¢˜ï¼Œæä¾›æ›´è¯¦ç»†çš„ç¤ºä¾‹å’Œè§£é‡Šã€‚
  æ‚¨éœ€è¦å¹«åŠ©ç·¨å¯« Solidity ä»£ç¢¼å—ï¼Ÿä»¥ä¸‹æ˜¯ä¸åŒæ‡‰ç”¨å ´æ™¯çš„ç¯„ä¾‹ï¼Œæˆ‘å¯ä»¥ç”¨ã€Œç´°åš¼æ…¢åš¥ã€çš„æ–¹å¼é€æ­¥è§£æã€‚è«‹å‘Šè¨´æˆ‘æ‚¨æƒ³å¯¦ç¾çš„åŠŸèƒ½é¡å‹ï¼ˆä¾‹å¦‚ NFTã€ä»£å¹£åˆç´„ã€å»ä¸­å¿ƒåŒ–å­˜å„²æ•´åˆç­‰ï¼‰ï¼Œæˆ‘æœƒæä¾›è©³ç´°è¨»è§£ç‰ˆä»£ç¢¼ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è¦‹æ–¹å‘ï¼š

---

### ğŸ› ï¸ **åŸºç¤æ¨¡æ¿ï¼šæ™ºèƒ½åˆç´„çµæ§‹åˆ†è§£**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 1. åˆç´„è²æ˜
contract Example {
    // 2. ç‹€æ…‹è®Šé‡ï¼ˆæ•¸æ“šå­˜å„²åœ¨å€å¡Šéˆä¸Šï¼‰
    address public owner;
    uint256 public value;

    // 3. äº‹ä»¶ï¼ˆç”¨æ–¼å‰ç«¯ç›£è½ï¼‰
    event ValueChanged(address indexed changer, uint256 newValue);

    // 4. æ§‹é€ å‡½æ•¸ï¼ˆéƒ¨ç½²æ™‚é‹è¡Œä¸€æ¬¡ï¼‰
    constructor() {
        owner = msg.sender; // msg.sender æ˜¯éƒ¨ç½²è€…çš„åœ°å€
    }

    // 5. å‡½æ•¸ä¿®é£¾ç¬¦ï¼ˆæ¬Šé™æ§åˆ¶ï¼‰
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _; // è¡¨ç¤ºç¹¼çºŒåŸ·è¡Œä¿®é£¾ç¬¦å¾Œçš„å‡½æ•¸
    }

    // 6. å¯è®Šæ›´åˆç´„ç‹€æ…‹çš„å‡½æ•¸ï¼ˆæ¶ˆè€— Gasï¼‰
    function setValue(uint256 _newValue) external onlyOwner {
        value = _newValue;
        emit ValueChanged(msg.sender, _newValue); // è§¸ç™¼äº‹ä»¶
    }

    // 7. è¦–åœ–å‡½æ•¸ï¼ˆåƒ…è®€å–æ•¸æ“šï¼Œä¸æ¶ˆè€— Gasï¼‰
    function getValue() external view returns (uint256) {
        return value;
    }
}
```

---

### ğŸ“¸ **å ´æ™¯ 1ï¼šNFT æ”å½±ä½œå“åˆç´„ï¼ˆå« IPFS æ•´åˆï¼‰**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract DecentralizedPhotoNFT is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    // å®šç¾©å…ƒæ•¸æ“šçµæ§‹ï¼ˆå­˜å„²åœ¨ IPFS çš„ CIDï¼‰
    struct PhotoMetadata {
        string ipfsCID;  // ä¾‹å¦‚ "QmXyZ...123"
        uint256 timestamp;
        address photographer;
    }

    mapping(uint256 => PhotoMetadata) private _photoData;

    constructor() ERC721("DecentralizedPhotos", "DPHOTO") {}

    // é‘„é€  NFTï¼ˆæ”å½±å¸«èª¿ç”¨ï¼‰
    function mintPhotoNFT(string memory ipfsCID) external {
        uint256 tokenId = _tokenIdCounter.current();
        _safeMint(msg.sender, tokenId);
        _photoData[tokenId] = PhotoMetadata({
            ipfsCID: ipfsCID,
            timestamp: block.timestamp,
            photographer: msg.sender
        });
        _tokenIdCounter.increment();
    }

    // æŸ¥è©¢ç…§ç‰‡å…ƒæ•¸æ“š
    function getPhotoMetadata(uint256 tokenId) 
        external 
        view 
        returns (PhotoMetadata memory) 
    {
        require(_exists(tokenId), "Token does not exist");
        return _photoData[tokenId];
    }

    // è¦†å¯« ERC721 çš„ tokenURI ä»¥æŒ‡å‘ IPFS
    function tokenURI(uint256 tokenId) 
        public 
        view 
        override 
        returns (string memory) 
    {
        require(_exists(tokenId), "Token does not exist");
        return string(abi.encodePacked(
            "ipfs://",
            _photoData[tokenId].ipfsCID
        ));
    }
}
```

#### ğŸ§© é—œéµæŠ€è¡“é»è§£æï¼š
1. **IPFS æ•´åˆ**ï¼šç…§ç‰‡æ–‡ä»¶å­˜å„²åœ¨ IPFSï¼Œåˆç´„åƒ…ä¿å­˜ CIDï¼ˆå…§å®¹æ¨™è­˜ç¬¦ï¼‰ã€‚
2. **æ¬Šé™æ§åˆ¶**ï¼šåªæœ‰æ”å½±å¸«æœ¬äººå¯ä»¥é‘„é€ è‡ªå·±çš„ NFTã€‚
3. **OpenZeppelin åº«**ï¼šä½¿ç”¨æ¨™æº– ERC721 å¯¦ç¾ï¼Œç¢ºä¿å…¼å®¹éŒ¢åŒ…å’Œå¸‚å ´ã€‚
4. **Gas å„ªåŒ–**ï¼š`_safeMint` é˜²æ­¢è½‰ç§»åˆ°ç„¡æ³•è™•ç† NFT çš„åˆç´„åœ°å€ã€‚

---

### ğŸ’° **å ´æ™¯ 2ï¼šæ”å½±ç‰ˆç¨…åˆ†ç™¼åˆç´„ï¼ˆè‡ªå‹•åŒ–æ”¯ä»˜ï¼‰**
```solidity
pragma solidity ^0.8.0;

contract PhotoRoyalty {
    struct RoyaltyRule {
        address payable receiver; // æ¥æ”¶æ–¹åœ°å€
        uint256 percentage;       // ç™¾åˆ†æ¯”ï¼ˆä¾‹å¦‚ 1000 = 10%ï¼‰
    }

    // è¨˜éŒ„æ¯å¼µç…§ç‰‡çš„ç‰ˆç¨…è¦å‰‡
    mapping(uint256 => RoyaltyRule[]) public photoRoyalties;

    // æ·»åŠ ç‰ˆç¨…è¦å‰‡ï¼ˆåƒ…é™æ‰€æœ‰è€…ï¼‰
    function setRoyalty(
        uint256 photoId,
        address payable receiver,
        uint256 percentage
    ) external {
        // éœ€æ·»åŠ æ¬Šé™æ§åˆ¶ï¼ˆä¾‹å¦‚ NFT æ‰€æœ‰è€…ï¼‰
        photoRoyalties[photoId].push(RoyaltyRule(receiver, percentage));
    }

    // è‡ªå‹•åˆ†ç™¼è³‡é‡‘ï¼ˆåœ¨ NFT éŠ·å”®æ™‚èª¿ç”¨ï¼‰
    function distributeFunds(uint256 photoId) external payable {
        RoyaltyRule[] storage rules = photoRoyalties[photoId];
        uint256 totalSent;

        for (uint256 i = 0; i < rules.length; i++) {
            uint256 amount = (msg.value * rules[i].percentage) / 10000;
            (bool sent, ) = rules[i].receiver.call{value: amount}("");
            require(sent, "Payment failed");
            totalSent += amount;
        }

        // å‰©é¤˜è³‡é‡‘è½‰çµ¦è³£å®¶
        uint256 remaining = msg.value - totalSent;
        (bool success, ) = msg.sender.call{value: remaining}("");
        require(success, "Refund failed");
    }
}
```

#### âš ï¸ å®‰å…¨æ³¨æ„äº‹é …ï¼š
- ä½¿ç”¨ `call{value:}()` è€Œé `transfer()` ä»¥é¿å… Gas ä¸è¶³å•é¡Œã€‚
- ç™¾åˆ†æ¯”è¨ˆç®—ä½¿ç”¨ `10000` åŸºç¤å–®ä½æ”¯æŒå°æ•¸ï¼ˆå¦‚ 123 = 1.23%ï¼‰ã€‚
- éœ€æ·»åŠ é‡å…¥æ”»æ“Šé˜²è­·ï¼ˆä¾‹å¦‚ OpenZeppelin çš„ ReentrancyGuardï¼‰ã€‚

---

éœ€è¦æˆ‘é‡å°æŸå€‹éƒ¨åˆ†æ›´è©³ç´°èªªæ˜ï¼Œæˆ–æ˜¯æä¾›å…¶ä»–é¡å‹çš„åˆç´„ç¯„ä¾‹å—ï¼Ÿè«‹å‘Šè¨´æˆ‘æ‚¨çš„å…·é«”éœ€æ±‚æ–¹å‘ã€‚
